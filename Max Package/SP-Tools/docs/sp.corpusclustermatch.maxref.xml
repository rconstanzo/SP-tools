<?xml version='1.0' encoding='utf-8' standalone='yes'?>
<?xml-stylesheet href="./_c74_ref.xsl" type="text/xsl"?>

<c74object name='sp.corpusclustermatch' category='' module='SP-Tools'>
    <digest>Cluster-based corpus matching
</digest>
    <description>Cluster-based corpus matching.
</description>
    <discussion><h4><openfilelink filename="SP-Tools Overview.maxpat">Open the Overview Patch</openfilelink></h4>
The <o>sp.corpusclustermatch</o> object lets you load a corpus like you would with <o>sp.corpusmatch</o> but instead of finding the nearest match based on descriptor input, you instead specify an amount of clusters to break the corpus in to and then you can play a random selection from each cluster based on an index corresponding with the cluster (or a normalized float between 0. and 1.).
</discussion>

	<metadatalist>
		<metadata name='author'>Rodrigo Constanzo, Flucoma Project</metadata>
		<metadata name='tag'>Machine Learning</metadata>
		<metadata name='tag'>Audio Analysis</metadata>
		<metadata name='tag'>Onset Detection</metadata>
		<metadata name='tag'>Corpus Playback</metadata>
	</metadatalist>

    <!-- INLETS -->
    <inletlist>
        <inlet id='0' type='list'>
            <digest>Control in
</digest>
            <description>Control input.
</description>
        </inlet>
    </inletlist>
    <!-- INLETS -->

    <!-- OUTLETS -->
    <outletlist>
        <outlet id='0' type='list'>
            <digest>Matched entry
</digest>
            <description>Matched entry.
</description>
        </outlet>
        <outlet id='1' type='list'>
            <digest>Dict output for <o>sp.plotter</o>
</digest>
            <description>Dict output for <o>sp.plotter</o>.
</description>
        </outlet>
    </outletlist>
    <!-- OUTLETS -->

    <!-- ARGUMENTS -->
    <objarglist>
        <objarg name='default' optional='1' type='symbol'>
            <digest>JSON file to load by default
</digest>
            <description>JSON file to load by default.
</description>
        </objarg>
    </objarglist>
    <!-- ARGUMENTS -->

    <!--MESSAGES-->
    <methodlist>
    <method name='corpus'>
        <arglist>
        </arglist>
        <digest>Messages related to corpus matching
</digest>
        <description>Messages related to corpus matching.
After sending the <m>corpus</m> message you send an argument of &#39;match&#39; followed by a time-scale you wish to match against.
The available options are:
<strong>short</strong> = the first 256 samples (at 44.1k sample rate)
<strong>medium</strong> = the first 4410 samples (at 44.1k sample rate)
<strong>all</strong> = the entire file
Therefore a complete message would look as follows:
&#39;corpus match all&#39; or &#39;corpus match small&#39;
</description>
    </method>
    <method name='filter'>
        <arglist>
        </arglist>
        <digest>Messages related to corpus filtering
</digest>
        <description>Messages related to corpus filtering.
After sending the <m>filter</m> message you send a series of additional arguments that determine what descriptor is being filtered, how it is being filtered, as well as further filtering strands combined with conditionals.
The available descriptors that can be used for filtering are:
<strong>duration</strong> =  overall sample duration in <strong>ms</strong>
<strong>time_centroid</strong> = how long a sample &#39;sounds&#39; in <strong>ms</strong>
<strong>loudness</strong> = loudness in <strong>dB</strong>
<strong>centroid</strong> = centroid in <strong>MIDI pitch</strong>
<strong>flatness</strong> = spectral flatness in <strong>dB</strong>
<strong>pitch</strong> = pitch in <strong>MIDI pitch</strong>
<strong>pitch_confidence</strong> = pitch confidence in <strong>0 to 1</strong>
<strong>loudness_medium</strong> = same for medium time frame
<strong>centroid_medium</strong> = same for medium time frame
<strong>flatness_medium</strong> = same for medium time frame
<strong>pitch_medium</strong> = same for medium time frame
<strong>pitch_confidence_medium</strong> = same for medium time frame
<strong>loudness_all</strong> = same for entire sample
<strong>centroid_all</strong> = same for entire sample
<strong>flatness_all</strong> = same for entire sample
<strong>pitch_all</strong> = same for entire sample
<strong>pitch_confidence_all</strong> = same for entire sample
<strong>index</strong> = the sample index in the corpus
You can filter by the following operators:
<strong>==</strong> = equals
<strong>!=</strong> = does not equal
<strong>&lt;</strong> = less than
<strong>&lt;=</strong> = less than or equal
<strong>&gt;</strong> = greater than
<strong>&gt;=</strong> = greater than or equal
You can join multiple queries using:
<strong>and</strong>
<strong>or</strong>
Therefore a complete message would look as follows:
&#39;filter loudness &lt; -45&#39; or &#39;filter duration &gt; 2500&#39; or &#39;filter centroid &gt; 60 and time_centroid &lt; 80&#39;
To reset the filtering you can send the following message:
&#39;filter reset&#39;
</description>
    </method>
    <method name='float'>
        <arglist>
        </arglist>
        <digest>Select a random sample from given cluster in normalized range
</digest>
        <description>Select a random sample from given cluster in normalized range (from 0. to 1.).
</description>
    </method>
    <method name='info'>
        <arglist>
        </arglist>
        <digest>Print corpus metatdata/info to Max console
</digest>
        <description>Prints a summary of the corpus metatdata/info to the Max console.
</description>
    </method>
    <method name='int'>
        <arglist>
        </arglist>
        <digest>Select a random sample from given cluster
</digest>
        <description>Select a random sample from given cluster (counting from 1).
</description>
    </method>
    <method name='load'>
        <arglist>
        </arglist>
        <digest>Load a pre-trained corpus <strong>.json</strong> file
</digest>
        <description>Opens file dialog to select pre-trained corpus <strong>.json</strong> file.
</description>
    </method>
    <method name='print'>
        <arglist>
        </arglist>
        <digest>Print dataset contents to Max console
</digest>
        <description>Prints a summary of the descriptors in the dataset to the Max console.
</description>
    </method>
    <method name='read'>
        <arglist>
        </arglist>
        <digest>Read a pre-trained corpus <strong>.json</strong> file
</digest>
        <description>Reads a pre-trained corpus <strong>.json</strong> file directly from a relative or absolute path.
</description>
    </method>
    <method name='seed'>
        <arglist>
        </arglist>
        <digest>Messages related to seeding the clusters
</digest>
        <description>Messages related to seeding the clusters
After sending the <m>seed</m> message you send a either a <m>read</m> or <m>load</m> message to load a pre-analyzed set of classes as defined by <o>sp.classcreate</o>. This will use those classes as &#39;seeds&#39; for the clustering process.
Therefore a complete message would look as follows:
&#39;seed read snaretraining.json&#39; or &#39;seed load&#39;
</description>
    </method>
	</methodlist>
	<!--MESSAGES-->

	<!--ATTRIBUTES-->
	<attributelist>
        <attribute 
        name='clusters' 
        type='int' 
        size='1'
        get='1' set='1' 
        >
        <digest>Amount of clusters to divide the corpus into
</digest>
        <description>Amount of clusters to divide the corpus into.
</description>

        <attributelist>
            <attribute 
            name='default' 
            type='int' 
            size='1' 
            value='8'
            get='1' set='1' 
            />
        </attributelist>
        </attribute>
        <attribute 
        name='sort' 
        type='symbol' 
        size='1'
        get='1' set='1' 
        >
        <digest>Sorting for clusters
</digest>
        <description>Sorting for the created clusters (loudness, centroid, flatness, pitch, none).
</description>

        <attributelist>
            <attribute 
            name='default' 
            type='symbol' 
            size='1' 
            value='centroid'
            get='1' set='1' 
            />
        </attributelist>
        </attribute>
	</attributelist>
	<!--ATTRIBUTES-->

	<!-- SEEALSO -->
	<seealsolist>
        <seealso name='sp.classcreate' />
        <seealso name='sp.classmatch' />
        <seealso name='sp.clustercreate' />
        <seealso name='sp.corpuscreate' />
        <seealso name='sp.corpusmatch' />
        <seealso name='sp.corpusplayer~' />
        <seealso name='sp.sampler~' />
        <seealso name='sp.plotter' />
	</seealsolist>
	<!-- SEEALSO -->
</c74object>